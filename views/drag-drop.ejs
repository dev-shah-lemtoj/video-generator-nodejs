<% var title = "Drag & Drop Canvas"; %>
<%- contentFor('HeaderCss') %>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<!-- SweetAlert2 CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>


<style>
.component-block {
  cursor: move;
}
.layout-header {
  cursor: move;
}

  .layout-box {
  height: 20px;
  justify-content: center;
  align-items: center;
}
.layout-column {
  position: relative;
  width: 100%;
  height: 100%;      /* ensure full height */
  box-sizing: border-box;
  padding: 10px;     /* or whatever padding */
  /* Add a background or border if needed to visualize */
}
.drop-placeholder {
  transition: opacity 0.2s ease-in-out;
}

.layout-column.has-component .drop-placeholder {
  display: none;
}

.box {
  background-color: #ccc;
  height: 100%;
  min-width: 20px;
  border-radius: 2px;
}

</style>
<%- contentFor('body') %>

<div class="d-flex" style="min-height: 80vh;">

  <!-- Sidebar for components -->
  <div class="p-3 bg-white border-end" style="width: 250px;">
   
    <div class="text-center my-3">
  <h5>Add Layout</h5>
  <div class="border rounded p-2 text-center cursor-grab layout-choice" data-layout="1" draggable="true">
  <div class="layout-box d-flex gap-1">
    <div class="box flex-grow-1"></div> 
  </div>
</div>

<div class="border rounded p-2 text-center cursor-grab layout-choice" data-layout="2" draggable="true">
  <div class="layout-box d-flex gap-1">
    <div class="box flex-grow-1"></div>
    <div class="box flex-grow-1"></div>
  </div>
</div>

<div class="border rounded p-2 text-center cursor-grab layout-choice" data-layout="3" draggable="true">
  <div class="layout-box d-flex gap-1">
    <div class="box flex-grow-1"></div>
    <div class="box flex-grow-1"></div>
    <div class="box flex-grow-1"></div>
  </div>
</div>
</div>
    <div class="d-flex flex-column gap-2">
      <h5 class="mb-3">Add Components</h5>
      <% Object.entries(icons).forEach(([type, icon]) => { %>
        <div 
          class="border rounded p-2 text-center cursor-grab draggable-component"
          data-type="<%= type %>"
          draggable="true">
          <i data-lucide="<%= icon %>"></i> &nbsp; <%= type %>
        </div>
      <% }) %>
    </div>
  </div>

  <!-- Canvas area -->

<div class="flex-grow-1 p-4">
<div class="d-flex justify-content-end mb-3">
  <button class="btn btn-success" onclick="previewCanvas()">Preview</button>
</div>

    <!--<h5 class="text-center mb-3">Drag components here</h5>-->
    <div 
      id="drop-canvas"
      class="border border-dashed p-5 text-center bg-light"
      style="min-height: 500px; background-color:   lightgray !important;""
      ondragover="event.preventDefault()"
      ondrop="handleDrop(event)">
    </div>
  </div>
</div>
<div id="canvasAlertBox" style="position: fixed; top: 20px; right: 20px; z-index: 1050;"></div>
<!-- Edit Modal -->
<div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="editModalLabel">Edit Component</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="editContentArea"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" id="saveChangesBtn">Save Changes</button>
      </div>
    </div>
  </div>
</div>
<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="settingsModalLabel">Component Settings</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="settingsContentArea">
                <div class="mb-3">
                    <label for="marginInput" class="form-label">Margin</label>
                    <input type="text" id="marginInput" class="form-control" placeholder="e.g., 10px">
                </div>
                <div class="mb-3">
                    <label for="paddingInput" class="form-label">Padding</label>
                    <input type="text" id="paddingInput" class="form-control" placeholder="e.g., 10px">
                </div>
                <div class="mb-3">
                    <label for="customClassInput" class="form-label">Custom Class</label>
                    <input type="text" id="customClassInput" class="form-control" placeholder="e.g., my-custom-class">
                </div>
                <div class="mb-3">
                    <label for="customIdInput" class="form-label">Custom ID</label>
                    <input type="text" id="customIdInput" class="form-control" placeholder="e.g., my-custom-id">
                </div>
            </div>
            <div class="modal-footer settings-modal-footer"> <!-- New class added here -->
                <button type="button" class="btn btn-primary" id="saveSettingsBtn">Save Changes</button>
            </div>
        </div>
    </div>
</div>
<%- contentFor('FooterJs') %>
<script src="https://unpkg.com/lucide@latest"></script>
<script>
function openSettingsModal(contentWrapper) {
    const marginInput = document.getElementById('marginInput');
    const paddingInput = document.getElementById('paddingInput');
    const customClassInput = document.getElementById('customClassInput');
    const customIdInput = document.getElementById('customIdInput');

    // Get current styles
    const currentMargin = window.getComputedStyle(contentWrapper).margin;
    const currentPadding = window.getComputedStyle(contentWrapper).padding;
    const currentClass = contentWrapper.className;
    const currentId = contentWrapper.id;

    // Set the values in the modal inputs
    marginInput.value = currentMargin;
    paddingInput.value = currentPadding;
    customClassInput.value = currentClass.includes(' ') ? currentClass.split(' ').pop() : ''; // Get the last class
    customIdInput.value = currentId || ''; // Get the current ID

    // Show the modal
    const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
    settingsModal.show();

    // Save settings on button click
    document.getElementById('saveSettingsBtn').onclick = () => {
        const newMargin = marginInput.value;
        const newPadding = paddingInput.value;
        const newClass = customClassInput.value;
        const newId = customIdInput.value;

        // Apply the new styles
        contentWrapper.style.margin = newMargin;
        contentWrapper.style.padding = newPadding;

        // Remove existing custom classes and add the new one
        contentWrapper.className = contentWrapper.className.split(' ').filter(c => !c.startsWith('custom-class')).join(' ') + ' ' + newClass;

        // Set the new ID
        contentWrapper.id = newId;

        // Hide the modal
        settingsModal.hide();
    };
}

 // Add drag-and-drop functionality for reordering components
  
function previewCanvas() {
  // Hide all edit buttons
  document.querySelectorAll('.hide-edit-button').forEach(btn => {
    btn.style.display = 'none'; // Hide the edit buttons
  });
  const canvasContent = document.getElementById('drop-canvas').innerHTML; // Get the current canvas content
  localStorage.setItem('canvasContent', canvasContent); // Save it to local storage
  window.location.href = '/preview'; // Redirect to the preview page
}
 function showCanvasAlert(message) {
  const alertBox = document.getElementById('canvasAlertBox');
  const alertId = `alert-${Date.now()}`;

  const alertHTML = `
    <div id="${alertId}" class="alert alert-danger alert-dismissible fade show" role="alert">
      <strong>Warning:</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
  `;

  alertBox.insertAdjacentHTML('beforeend', alertHTML);

  // Auto dismiss after 3 seconds
  setTimeout(() => {
    const el = document.getElementById(alertId);
    if (el) {
      el.classList.remove('show');
      el.classList.add('hide');
      el.addEventListener('transitionend', () => el.remove());
    }
  }, 3000);
}



  document.querySelectorAll('.layout-choice').forEach(el => {
  el.addEventListener('dragstart', e => {
    e.dataTransfer.setData('layout', e.target.dataset.layout);
  });
});
  lucide.createIcons();

  const dropCanvas = document.getElementById('drop-canvas');
  const components = document.querySelectorAll('.draggable-component');
  
  
  let currentEditTarget = null;
  let currentComponentType = null;

  components.forEach(el => {
    el.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', e.target.dataset.type);
      e.dataTransfer.setData('source', 'toolbar'); 
    });
  });

function handleDrop(e) {
    e.preventDefault();
    const layoutType = e.dataTransfer.getData('layout');
    const type = e.dataTransfer.getData('text/plain');
    const dropTarget = e.target.closest('.layout-column');
    // If a layout type is being dropped, add a new layout
    if (layoutType) {
        addLayoutToCanvas(parseInt(layoutType), dropCanvas);
        return;
    }
    // If a component type is being dropped
    if (type) {
        // Check if the drop target is a valid component area
        if (!dropTarget) {
            showCanvasAlert('Please add a layout before dropping a component.');
            return;
        }
        // If the drop target is a valid component area, add the component
        // addComponentToCanvas(type, dropTarget);
    }
}

function moveComponent(component, direction) {
    const parent = component.parentElement;
    if (direction === 'up' && component.previousElementSibling) {
        parent.insertBefore(component, component.previousElementSibling);
    } else if (direction === 'down' && component.nextElementSibling) {
        parent.insertBefore(component.nextElementSibling, component);
    }
}

function openLayoutSettingsModal(layoutElement) {
    const marginInput = document.getElementById('marginInput');
    const paddingInput = document.getElementById('paddingInput');
    const customClassInput = document.getElementById('customClassInput');
    const customIdInput = document.getElementById('customIdInput');

    // Get current styles
    const currentMargin = window.getComputedStyle(layoutElement).margin;
    const currentPadding = window.getComputedStyle(layoutElement).padding;
    const currentClass = layoutElement.className;
    const currentId = layoutElement.id;

    // Set the values in the modal inputs
    marginInput.value = currentMargin;
    paddingInput.value = currentPadding;
    customClassInput.value = currentClass.includes(' ') ? currentClass.split(' ').pop() : ''; // Get the last class
    customIdInput.value = currentId || ''; // Get the current ID

    // Show the modal
    const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
    settingsModal.show();

    // Save settings on button click
    document.getElementById('saveSettingsBtn').onclick = () => {
        const newMargin = marginInput.value;
        const newPadding = paddingInput.value;
        const newClass = customClassInput.value;
        const newId = customIdInput.value;

        // Apply the new styles
        layoutElement.style.margin = newMargin;
        layoutElement.style.padding = newPadding;

        // Remove existing custom classes and add the new one
        layoutElement.className = layoutElement.className.split(' ').filter(c => !c.startsWith('custom-class')).join(' ') + ' ' + newClass;

        // Set the new ID
        layoutElement.id = newId;

        // Hide the modal
        settingsModal.hide();
    };
}


function addLayoutToCanvas(columns = 1, target = dropCanvas) {
    const row = document.createElement('div');
    row.className = 'row g-2 mb-3 position-relative';
    for (let i = 0; i < columns; i++) {
        const col = document.createElement('div');
        col.className = 'col layout-column border rounded p-3 bg-white';
        col.style.minHeight = '100px';
        col.innerHTML = `
            <div class="drop-placeholder text-center text-muted py-5" style="border: 2px dashed #ccc; display: none;">
                <i data-lucide="plus-circle" class="mb-2"></i><br/>
                Drop here
            </div>
        `;
        // Drop handlers
        col.addEventListener('dragover', e => e.preventDefault());
        col.addEventListener('dragenter', () => {
            col.querySelector('.drop-placeholder').style.display = 'block';
        });
        col.addEventListener('dragleave', () => {
            col.querySelector('.drop-placeholder').style.display = 'none';
        });
        col.addEventListener('drop', e => {
            e.preventDefault();
            col.querySelector('.drop-placeholder').style.display = 'none';
            // ✅ Only accept drops from toolbar
            const type = e.dataTransfer.getData('text/plain');
            const source = e.dataTransfer.getData('source');
            if (source === 'toolbar' && type) {
                addComponentToCanvas(type, col);
            }
        });
        row.appendChild(col);
    }

  // Create a smaller delete button for the entire layout
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'btn btn-danger btn-sm p-1'; // Smaller button with padding
  deleteBtn.innerHTML = `<i data-lucide="trash-2" style="font-size: 1rem;"></i>`; // Icon size
  deleteBtn.style.position = 'absolute';
  deleteBtn.style.top = '10px';
  deleteBtn.style.right = '10px';
  deleteBtn.style.zIndex = '10'; // Ensure it appears above other elements
  deleteBtn.style.borderRadius = '50%'; // Make it circular
  deleteBtn.style.width = '30px'; // Set width
  deleteBtn.style.height = '30px'; // Set height
  deleteBtn.style.display = 'flex'; // Center the icon
  deleteBtn.style.alignItems = 'center'; // Center the icon vertically
  deleteBtn.style.justifyContent = 'center'; // Center the icon horizontally

  deleteBtn.onclick = () => {
    Swal.fire({
      title: 'Are you sure?',
      text: "You won't be able to revert this!",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonText: 'Yes, delete it!',
      cancelButtonText: 'Cancel',
      customClass: {
        confirmButton: 'btn btn-primary w-xs me-2',
        cancelButton: 'btn btn-light w-xs',
      },
      buttonsStyling: false
    }).then((result) => {
      if (result.isConfirmed) {
        row.remove();
        Swal.fire({
          title: 'Deleted!',
          text: 'Your layout has been deleted.',
          icon: 'success',
          timer: 1500,
          showConfirmButton: false
        });
      }
    });
  };
  
  const settingsBtn = document.createElement('button');
    settingsBtn.className = 'btn btn-info btn-sm p-1'; // Smaller button with padding
    settingsBtn.innerHTML = `<i data-lucide="settings" style="font-size: 1rem;"></i>`; // Icon size
    settingsBtn.style.position = 'absolute';
    settingsBtn.style.top = '50px'; // Adjust as needed to position below the delete button
    settingsBtn.style.right = '10px';
    settingsBtn.style.zIndex = '10'; // Ensure it appears above other elements
    settingsBtn.style.borderRadius = '50%'; // Make it circular
    settingsBtn.style.width = '30px'; // Set width
    settingsBtn.style.height = '30px'; // Set height
    settingsBtn.style.display = 'flex'; // Center the icon
    settingsBtn.style.alignItems = 'center'; // Center the icon vertically
    settingsBtn.style.justifyContent = 'center'; // Center the icon horizontally
    
    
    // Append the settings button to the row
    settingsBtn.addEventListener('click', () => {
        openLayoutSettingsModal(row); // Pass the layout row element
    });

  // Append the delete button to the row
  row.appendChild(deleteBtn);
  row.appendChild(settingsBtn);
  target.appendChild(row);
  lucide.createIcons();
}




  function addLayout(cols) {
  const layoutRow = document.createElement('div');
  layoutRow.className = 'd-flex gap-2 mb-3 layout-row';

  for (let i = 0; i < cols; i++) {
    const col = document.createElement('div');
    col.className = 'flex-fill border p-3 bg-white layout-column';
    col.setAttribute('ondragover', 'event.preventDefault()');
    col.setAttribute('ondrop', 'handleDrop(event)');
    col.innerHTML = `<div class="text-muted text-center">Column ${i + 1}</div>`;
    layoutRow.appendChild(col);
  }

  dropCanvas.appendChild(layoutRow);
}

  async function addComponentToCanvas(type,targetContainer = dropCanvas) {
    currentComponentType = type;
    const element = document.createElement('div');
    element.className = "position-relative p-3 mb-2 border rounded bg-white text-start component-block";

    const contentWrapper = document.createElement('div');
    contentWrapper.className = "component-content";
    contentWrapper.style.margin = "32px";

    let editableContent = "";

    switch (type) {
      case "slider":
        const id = `carousel-${Date.now()}`;
        editableContent = `
          <div id="${id}" class="carousel slide" data-bs-ride="carousel" style="max-width: auto;">
            <div class="carousel-inner rounded">
              <div class="carousel-item active">
                <img src="https://placehold.co/600x400?text=Slide+1" class="d-block w-100" alt="Slide 1">
              </div>
              <div class="carousel-item">
                <img src="https://placehold.co/600x400?text=Slide+2" class="d-block w-100" alt="Slide 2">
              </div>
            </div>
            <button class="carousel-control-prev" type="button" data-bs-target="#${id}" data-bs-slide="prev">
              <span class="carousel-control-prev-icon" aria-hidden="true"></span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#${id}" data-bs-slide="next">
              <span class="carousel-control-next-icon" aria-hidden="true"></span>
            </button>
            <div class="carousel-indicators">
              <button type="button" data-bs-target="#${id}" data-bs-slide-to="0" class="active"></button>
              <button type="button" data-bs-target="#${id}" data-bs-slide-to="1"></button>
            </div>
          </div>`;
        break;

      case "ad image":
        editableContent = `
          <div style="max-width: auto;">
            <img src="https://placehold.co/600x400" class="img-fluid rounded" alt="Ad Image" />
          </div>`;
        break;

      case "grid":
        editableContent = await generateGridHTML(3, 4); // Default 3 columns, 1 row
        break;

      case "stories":
        editableContent = '<strong>Stories</strong><div class="mt-2 text-muted">[Story Placeholder]</div>';
        break;

      case "text":
        editableContent = '<p class="mt-2">This is a sample text block.</p>';
        break;

      case "custom css":
        editableContent = '<strong>Custom CSS</strong><pre class="mt-2 text-muted">body { background-color: #f0f0f0; }</pre>';
        break;

      case "custom JS":
        editableContent = '<strong>Custom JS</strong><pre class="mt-2 text-muted">console.log("Hello, World!");</pre>';
        break;

      default:
        editableContent = `<strong>${type}</strong><div class="text-muted">Component content here</div>`;
    }

    contentWrapper.innerHTML = editableContent;
    
    element.style.position = 'relative'; // Ensure this is set

    const buttonContainer = document.createElement('div');
    buttonContainer.className = "position-absolute top-0 end-0 d-flex gap-1 m-2";

    
    // Delete Button
    const deleteBtn = document.createElement('button');
deleteBtn.className = "btn btn-sm btn-outline-danger";
deleteBtn.innerHTML = `<i data-lucide="trash-2"></i>`;

deleteBtn.addEventListener('click', () => {
  Swal.fire({
    title: 'Are you sure?',
    text: "You won't be able to revert this!",
    icon: 'warning',
    showCancelButton: true,
    confirmButtonText: 'Yes, delete it!',
    cancelButtonText: 'Cancel',
    customClass: {
      confirmButton: 'btn btn-danger w-xs me-2',
      cancelButton: 'btn btn-light w-xs',
    },
    buttonsStyling: false
  }).then((result) => {
    if (result.isConfirmed) {
      element.remove();
      Swal.fire({
        title: 'Deleted!',
        text: 'The component has been removed.',
        icon: 'success',
        showConfirmButton: false,
        timer: 1500
      });
    }
  });
});

lucide.createIcons();

    
    const editBtn = document.createElement('button');
    editBtn.className = "btn btn-sm btn-outline-primary";
    editBtn.innerHTML = `<i data-lucide="edit-3"></i>`;
    
    const moveUpBtn = document.createElement('button');
    moveUpBtn.textContent = '⬆️';
    moveUpBtn.className = 'btn btn-sm btn-outline-secondary m-2';
    moveUpBtn.addEventListener('click', () => {
        moveComponent(element, 'up');
    });
    // Move Down Button
    const moveDownBtn = document.createElement('button');
    moveDownBtn.textContent = '⬇️';
    moveDownBtn.className = 'btn btn-sm btn-outline-secondary m-2';
    moveDownBtn.addEventListener('click', () => {
        moveComponent(element, 'down');
    });
    
    
    const settingsBtn = document.createElement('button');
    settingsBtn.className = "btn btn-sm btn-outline-info";
    settingsBtn.innerHTML = `<i data-lucide="settings"></i>`;
    settingsBtn.addEventListener('click', () => {
        openSettingsModal(contentWrapper);
    });
    
    


editBtn.addEventListener('click', () => {
  currentEditTarget = contentWrapper;
  currentComponentType = type;

  const html = currentEditTarget.innerHTML.trim();
  const isSlider = currentEditTarget.querySelector('.carousel');
  const isAdImage = currentEditTarget.querySelector('img') && !isSlider && type === "ad image";
  const isGrid = type === "grid";

  const contentArea = document.getElementById("editContentArea");

  if (isSlider) {
    contentArea.innerHTML = `
      <label class="form-label">Number of slides:</label>
      <input id="slideCountInput" type="number" min="1" max="10" value="2" class="form-control mb-3"/>
      <div id="imageInputsContainer" class="d-flex flex-column gap-2"></div>
    `;

    function renderVideosGrid(videos, cols, rows, videoCount, wrap = true) {
  let html = wrap ? `<div class="video-grid-container">` : '';
  let index = 0;

  for (let r = 0; r < rows; r++) {
    html += `<div class="row mb-3">`;
    for (let c = 0; c < cols && index < videos.length; c++, index++) {
      const video = videos[index];
      html += `
        <div class="col">
          <div class="card h-100">
            ${video.videoUrl
              ? `<video controls class="card-img-top" preload="metadata">
                   <source src="${video.videoUrl}" type="video/mp4">
                   Your browser does not support the video tag.
                 </video>`
              : `<div class="card-img-top d-flex align-items-center justify-content-center bg-light" style="height: 180px;">
                   <span class="text-muted">No video found</span>
                 </div>`}
            <div class="card-body">
              <h5 class="card-title">${video.title}</h5>
            </div>
          </div>
        </div>`;
    }
    html += `</div>`;
  }

  if (wrap) html += `</div>`;
  return html;
}


    const initialCount = isSlider.querySelectorAll('.carousel-item').length || 2;
    document.getElementById("slideCountInput").value = initialCount;
    renderVideoInputs(initialCount);

    document.getElementById("slideCountInput").addEventListener("input", (e) => {
      let count = Math.max(1, Math.min(10, parseInt(e.target.value)));
      renderVideoInputs(count);
    });

      } else if (isAdImage) {
        // Single image editor for ad image
        const imgEl = currentEditTarget.querySelector('img');
        const imgSrc = imgEl ? imgEl.src : "https://placehold.co/600x400";

        contentArea.innerHTML = `
          <label class="form-label">Ad Image:</label>
          <input type="file" accept="image/*" id="adImageInput" class="form-control mb-3" />
          <img id="adImagePreview" src="${imgSrc}" class="img-preview border rounded" width="300"/>
        `;

        document.getElementById('adImageInput').addEventListener('change', e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
              document.getElementById('adImagePreview').src = event.target.result;
            };
            reader.readAsDataURL(file);
          }
        });

      } else if (isGrid) {
        // Parse existing grid for rows and columns
        const playlistURL = currentEditTarget.getAttribute('data-playlist-url') || '';
  const videoCountAttr = currentEditTarget.getAttribute('data-video-count');
  const videoCount = parseInt(videoCountAttr)  ;
  const rows = currentEditTarget.querySelectorAll('.row').length || 1;
  const cols = currentEditTarget.querySelector('.row')?.children.length || 3;
        contentArea.innerHTML = `
  <label class="form-label">Number of Videos:</label>
  <input type="number" id="gridVideoCount" class="form-control mb-3" min="1" max="20" value="${videoCount}" />

  <label class="form-label">Columns:</label>
  <input type="number" id="gridColsInput" class="form-control mb-3" min="1" max="10" value="${cols}" />

  <label class="form-label">Fetch From:</label>
  <select id="videoSourceType" class="form-control mb-3">
    <option value="playlist">Playlist</option>
    <option value="category">Category</option>
  </select>

  <div id="playlistInput" class="mb-3">
    <label class="form-label">Playlist URL:</label>
    <input type="url" id="gridPlaylistURL" class="form-control" placeholder="Enter playlist URL" value="${playlistURL}" />
  </div>

  <div id="categoryInput" class="mb-3" style="display: none;">
    <label class="form-label">Search Term:</label>
    <input type="text" id="gridCategoryQuery" class="form-control" placeholder="e.g. maggie" />
  </div>

  <div class="alert alert-info">Adjust rows, columns, and video source. One video per cell will be shown.</div>
`;
const sourceSelect = document.getElementById('videoSourceType');
const playlistInput = document.getElementById('playlistInput');
const categoryInput = document.getElementById('categoryInput');

sourceSelect.addEventListener('change', () => {
  const isPlaylist = sourceSelect.value === 'playlist';
  playlistInput.style.display = isPlaylist ? 'block' : 'none';
  categoryInput.style.display = isPlaylist ? 'none' : 'block';
});

      }else if(type === "text"){
         contentArea.innerHTML = `
  <div id="editor" style="height: 200px;"></div>
`;
var quill = new Quill('#editor', {
  theme: 'snow'
});
quill.root.innerHTML = html;
      } else {
        // Default: simple editable HTML content
       quill = null; 
          contentArea.innerHTML = `
          <textarea id="genericContent" class="form-control" rows="8">${html}</textarea>
        `;

      }

      const editModal = new bootstrap.Modal(document.getElementById('editModal'));
      editModal.show();
      document.getElementById('saveChangesBtn').onclick = () => {
        if (isSlider) {
          const count = parseInt(document.getElementById('slideCountInput').value) || 2;
          const container = document.getElementById('imageInputsContainer');
          let slidesHTML = '';
          let indicatorsHTML = '';
          let quill = null;

    for (let i = 0; i < count; i++) {
      const videoInput = container.querySelector(`input.slide-video-input[data-index="${i}"]`);
      if (!videoInput) continue;

      const videoPreview = videoInput.parentElement.querySelector('video');
      const src = videoPreview?.src || 'https://www.w3schools.com/html/mov_bbb.mp4';

      slidesHTML += `
        <div class="carousel-item ${i === 0 ? 'active' : ''}">
          <video class="d-block w-100" controls>
            <source src="${src}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </div>`;
      
      indicatorsHTML += `<button type="button" data-bs-target="#carousel-edit" data-bs-slide-to="${i}" ${i === 0 ? 'class="active"' : ''}></button>`;
    }

    currentEditTarget.innerHTML = `
      <div id="carousel-edit" class="carousel slide" data-bs-ride="carousel" style="max-width: auto;">
        <div class="carousel-inner rounded">${slidesHTML}</div>
        <button class="carousel-control-prev" type="button" data-bs-target="#carousel-edit" data-bs-slide="prev">
          <span class="carousel-control-prev-icon" aria-hidden="true"></span>
        </button>
        <button class="carousel-control-next" type="button" data-bs-target="#carousel-edit" data-bs-slide="next">
          <span class="carousel-control-next-icon" aria-hidden="true"></span>
        </button>
        <div class="carousel-indicators">${indicatorsHTML}</div>
      </div>`;

    lucide.createIcons();

        } else if (isGrid) {
          const sourceType = document.getElementById('videoSourceType').value;
            const videoCount = parseInt(document.getElementById('gridVideoCount').value) || 12;
            const cols = parseInt(document.getElementById('gridColsInput').value) || 3;
            const playlistURL = document.getElementById('gridPlaylistURL').value.trim();
            const rows = Math.ceil(videoCount / cols);

            if (sourceType === 'playlist') {
            const playlistURL = document.getElementById('gridPlaylistURL').value.trim();
            generateGridHTML(cols, rows, playlistURL, videoCount).then(newGridHTML => {
              currentEditTarget.innerHTML = newGridHTML;
              lucide.createIcons();
            });
          } else {
            const categoryQuery = document.getElementById('gridCategoryQuery').value.trim();
            generateGridByCategory(cols, rows, categoryQuery, videoCount)
            .then(newGridHTML => {
              currentEditTarget.innerHTML = newGridHTML;
              lucide.createIcons();
            })
            .catch(console.error);
          }

        }else if(type === "text"){
            var quill = new Quill('#editor', {
            theme: 'snow'
            });
            console.log(quill);
            console.log(quill.root);
                currentEditTarget.innerHTML = quill.root.innerHTML;
                const modalInstance = bootstrap.Modal.getInstance(document.getElementById('editModal'));
                lucide.createIcons();
        }
         else {
          // Generic HTML update
          const newContent = document.getElementById('genericContent').value.trim();
          currentEditTarget.innerHTML = newContent;
        }

        const editModal = bootstrap.Modal.getInstance(document.getElementById('editModal'));
        editModal.hide();
        lucide.createIcons();
      };
    });
    element.appendChild(contentWrapper);
    buttonContainer.appendChild(editBtn);
    buttonContainer.appendChild(deleteBtn);
    buttonContainer.appendChild(settingsBtn);
    element.appendChild(buttonContainer); 
      targetContainer.appendChild(element);
       Sortable.create(targetContainer, {
        animation: 150,
        handle: '.component-block', // Drag handle
        onEnd: function (evt) {
            console.log('Component moved:', evt.item);
        }
    });
       lucide.createIcons()
requestAnimationFrame(() => lucide.createIcons(element));

  }
let currentVideoQuery = '';
let currentVideoSourceType = '';
let currentVideoCount = 0;
let currentCols = 3;
let nextPageToken = null;


function extractPlaylistId(url) {
  try {
    const urlObj = new URL(url);
    return urlObj.searchParams.get('list') || null;
  } catch {
    return null;
  }
}


let videoBuffer = [];        // store all videos fetched so far for current page
let bufferIndex = 0;         // how many videos shown from videoBuffer
let currentPage = 1;         // API page number
const pageSize = 12;         // fetch 56 videos per API call
const chunkSize = 12;        // show 12 videos per Load More click

let hasMore = true;
let totalVideos = 0;


async function fetchVideosByCategory(page = 1) {
  const url = `https://api.jwplayer.com/v2/sites/rxoMwaA5/media/?page=${page}&page_length=${pageSize}&sort=created%3Adsc`;
  const res = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'Authorization': 'T-tVXvNw5HquxLSS5A_G_2InU2xwbU5XcEpTMEV3ZUVweVJYaEhTRmRuZFVSQ1NXSncn'
    }
  });

  const data = await res.json();

  const totalVideos = data.total || 0;
  console.log(totalVideos);
  const hasMore = (data.page * data.page_length) < totalVideos;
  console.log(hasMore)

  const videos = await Promise.all(
    data.media.map(async (item) => {
      const mediaId = item.id;
      const mediaRes = await fetch(`https://cdn.jwplayer.com/v2/media/${mediaId}`);
      const mediaData = await mediaRes.json();
      return {
        mediaId,
        title: mediaData.title || 'Video not rendered',
        image: `https://cdn.jwplayer.com/v2/media/${mediaId}/poster.jpg?width=320`,
        videoUrl: mediaData.playlist?.[0]?.sources?.find(s => s.type === "video/mp4")?.file || ''
      };
    })
  );

  return { videos, totalVideos, hasMore };
}

async function generateGridByCategory(cols, rows, query) {
  // Reset state on new query
  videoBuffer = [];
  bufferIndex = 0;
  currentPage = 1;
  totalVideos = 0;
  totalPages = 0;
  hasMore = false;

  const { videos, totalVideos: total, hasMore: more } = await fetchVideosByCategory(currentPage);
  totalVideos = total;
  hasMore = more;
  totalPages = Math.ceil(totalVideos / pageSize);
  videoBuffer = videos;

  if (!videoBuffer || videoBuffer.length === 0) return '<div>No videos found.</div>';

  const initialVideos = videoBuffer.slice(bufferIndex, bufferIndex + chunkSize);
  bufferIndex += chunkSize;

  let html = renderVideosGrid(initialVideos, cols, Math.ceil(chunkSize / cols), chunkSize);

  if (hasMore) {
    html += `<div class="text-center mt-3"><button id="loadMoreBtn" class="btn btn-primary">Load More</button></div>`;
  }

  setTimeout(() => {
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', loadMoreVideos.bind(null, cols));
    }
  }, 100);

  return html;
}



function renderVideosGrid(videos, cols, rows, videoCount, wrap = true) {
  let html = wrap ? `<div class="video-grid-container">` : '';
  let index = 0;

  for (let r = 0; r < rows; r++) {
    html += `<div class="row mb-3">`;
    for (let c = 0; c < cols && index < videos.length; c++, index++) {
      const video = videos[index];
      html += `
        <div class="col">
          <div class="card h-100">
            ${video.videoUrl
              ? `<video controls class="card-img-top" preload="metadata">
                   <source src="${video.videoUrl}" type="video/mp4">
                   Your browser does not support the video tag.
                 </video>`
              : `<div class="card-img-top d-flex align-items-center justify-content-center" style="height: 180px; background-color: #f0f0f0;">
                   <span class="text-muted">No video found</span>
                 </div>`
            }
            <div class="card-body">
              <h5 class="card-title">${video.title}</h5>
            </div>
          </div>
        </div>`;
    }
    html += `</div>`;
  }

  if (wrap) html += `</div>`;
  return html;
}



async function loadMoreVideos(cols) {
  const container = document.querySelector('.video-grid-container');

  // Show next chunk from buffer if available
  if (bufferIndex < videoBuffer.length) {
    const nextVideos = videoBuffer.slice(bufferIndex, bufferIndex + chunkSize);
    bufferIndex += chunkSize;

    const html = renderVideosGrid(nextVideos, cols, Math.ceil(chunkSize / cols), chunkSize, false);
    container.insertAdjacentHTML('beforeend', html);
  }

  // If buffer exhausted AND there may be more to fetch
  if (bufferIndex >= videoBuffer.length && hasMore) {
    currentPage += 1;

    const { videos: newVideos, hasMore: more } = await fetchVideosByCategory(currentPage);

    if (newVideos.length === 0) {
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      if (loadMoreBtn) loadMoreBtn.remove();
      return;
    }

    // Append to buffer, do NOT reset
    videoBuffer = videoBuffer.concat(newVideos);
    hasMore = more;

    // Show next chunk from newly added videos
    const nextVideos = videoBuffer.slice(bufferIndex, bufferIndex + chunkSize);
    bufferIndex += chunkSize;

    const html = renderVideosGrid(nextVideos, cols, Math.ceil(chunkSize / cols), chunkSize, false);
    container.insertAdjacentHTML('beforeend', html);

    container.insertAdjacentHTML('beforeend', `<div class="pagination text-center mt-3">Page ${currentPage}</div>`);

    if (!hasMore) {
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      if (loadMoreBtn) loadMoreBtn.remove();
    }
  }
}








let playlistVideos = [];
let playlistNextPageToken = '';
let playlistId = '';

async function fetchPlaylistVideos(playlistId, pageToken = '') {
  const maxResults = 12; // Load 12 per click
  const response = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=${maxResults}&playlistId=${playlistId}&key=${YT_API_KEY}&pageToken=${pageToken}`);
  const data = await response.json();
  if (data.error) {
    console.error('YouTube API error:', data.error);
    return { videos: [], nextPageToken: '' };
  }
  return {
    videos: data.items,
    nextPageToken: data.nextPageToken || ''
  };
}


async function generateGridHTML(cols, rows, playlistURL = '', videoCount = 12) {
  currentCols = cols;
  currentVideoCount = cols * rows;
  currentVideoSourceType = 'playlist';

  if (!playlistURL) {
    let html = '';
    for (let r = 0; r < rows; r++) {
      html += '<div class="row mb-2">';
      for (let c = 0; c < cols; c++) {
        html += `<div class="col"><div class="border p-2 rounded bg-light text-center">Grid Cell</div></div>`;
      }
      html += '</div>';
    }
    return html;
  }

  const playlistId = extractPlaylistId(playlistURL);
  if (!playlistId) {
    return `<div class="alert alert-danger">Invalid playlist URL</div>`;
  }

  const videos = await fetchPlaylistVideos(playlistId);
  const trimmedVideos = videos.slice(0, currentVideoCount);

  let html = renderVideosGrid(trimmedVideos, cols, Math.ceil(trimmedVideos.length / cols), trimmedVideos.length);

  // Optional: Add Load More if your fetchPlaylistVideos supports pagination
  // (Commented out unless you add nextPageToken logic)
  /*
  if (nextPageToken) {
    html += `<div class="text-center mt-3"><button id="loadMoreBtn" class="btn btn-primary">Load More</button></div>`;
    setTimeout(() => {
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      if (loadMoreBtn) {
        loadMoreBtn.addEventListener('click', loadMoreVideos);
      }
    }, 100);
  }
  */

  return html;
}



  const YT_API_KEY = 'AIzaSyC5Vtg_R-1uQuAXB-B7OLe5OkNzIHNiZbA';  // <-- Insert your API key here


async function fetchPlaylistVideos(playlistId) {
  const maxResults = 50;
  let videos = [];
  let nextPageToken = '';
 
  do {
    const response = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=${maxResults}&playlistId=${playlistId}&key=${YT_API_KEY}&pageToken=${nextPageToken}`);
    const data = await response.json();
    if (data.error) {
      console.error('YouTube API error:', data.error);
      break;
    }
    videos = videos.concat(data.items);
    nextPageToken = data.nextPageToken || '';
  } while (nextPageToken && videos.length < maxResults);


  return videos;
}


function extractPlaylistId(url) {
  const urlObj = new URL(url);
  if (urlObj.searchParams.has('list')) {
    return urlObj.searchParams.get('list');
  }
  return null;
}


async function generateGridHTML(cols, rows, playlistURL = '', videoCount = 12) {
  if (!playlistURL) {
    // fallback: empty grid
    let html = '';
    for (let r = 0; r < rows; r++) {
      html += '<div class="row mb-2">';
      for (let c = 0; c < cols; c++) {
        html += `<div class="col"><div class="border p-2 rounded bg-light text-center">Grid Cell</div></div>`;
      }
      html += '</div>';
    }
    return html;
  }


  const playlistId = extractPlaylistId(playlistURL);
  if (!playlistId) {
    return `<div class="alert alert-danger">Invalid playlist URL</div>`;
  }


  const videos = await fetchPlaylistVideos(playlistId);


  let html = '';
  let videoIndex = 0;


  for (let r = 0; r < rows; r++) {
    html += '<div class="row mb-2">';
    for (let c = 0; c < cols; c++) {
      if (videoIndex < videos.length && videoIndex < videoCount) {
        const videoId = videos[videoIndex].snippet.resourceId.videoId;
        html += `
          <div class="col">
            <div class="border p-2 rounded bg-light text-center">
              <iframe width="100%" height="150" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe>
            </div>
          </div>`;
        videoIndex++;
      } else {
        // No more videos, fill empty cell
        html += `<div class="col"><div class="border p-2 rounded bg-light text-center">No Video</div></div>`;
      }
    }
    html += '</div>';
  }
  return html;
}





</script>

<!-- SweetAlert2 JS -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>